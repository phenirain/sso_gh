@startuml
namespace application {
}
namespace config {
    class "Config" << (S,Aquamarine) >> {
        + Env string
        + ConnectionString string
        + AllowedOrigins []string
        + Secret string
        + HTTP HTTPConfig

    }
    class "HTTPConfig" << (S,Aquamarine) >> {
        + Port int
        + Timeout time.Duration

    }
}
namespace contextkeys {
    class "contextkeys.CtxKey" << (T, #FF7700) >>  {
    }
}
namespace database {
}
namespace domain {
    class "User" << (S,Aquamarine) >> {
        + Id int64
        + RoleId int64
        + Login string
        + PasswordHash []byte
        + CreationTime time.Time
        + UpdateTime *time.Time
        + IsArchived bool

        - updateDateTime() 

        + CheckPassword(password string) bool
        + UpdateLogin(login string) 
        + UpdatePassword(oldPass string, newPass string) error
        + ChangeArchiveStatus(status bool) 

    }
}
namespace echomiddleware {
    interface "Jwt"  {
        + ParseToken(tokenString string) (int64, error)

    }
    interface "logger"  {
        + LogAttrs(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr) 

    }
}
namespace internal {
}
namespace auth {
    interface "AuthService"  {
        + Auth(ctx context.Context, request auth.AuthRequest, isNew bool) (*auth.AuthResponse, error)
        + Refresh(ctx context.Context, refreshToken string) (*auth.AuthResponse, error)

    }
    class "Handler" << (S,Aquamarine) >> {
        - s AuthService

        - auth(c echo.Context, isNew bool) error

        + LogIn(c echo.Context) error
        + SignUp(c echo.Context) error
        + Refresh(c echo.Context) error

    }
}
namespace auth {
    class "AuthRequest" << (S,Aquamarine) >> {
        + Login string
        + Password string

    }
    class "AuthResponse" << (S,Aquamarine) >> {
        + RefreshToken string
        + AccessToken string

    }
}
namespace response {
    class "ApiResponse" as ApiResponse_generic_T <<[T]>> {
        + Success bool
        + Message string
        + Data *T
        + Details string

    }
    class "T" <<type parameter>> {
        constraints: any
    }
}
namespace auth {
}
namespace jwt {
}
namespace jwt {
    class "JwtLib" << (S,Aquamarine) >> {
        - duration time.Duration
        - secret []byte

        + NewToken(userId int64) (string, string, error)
        + ParseToken(tokenString string) (int64, error)

    }
}
namespace user {
    class "UserRepository" << (S,Aquamarine) >> {
        - db *sqlx.DB

        + GetUserByLogin(ctx context.Context, login string) (*domain.User, error)
        + GetUserWithId(ctx context.Context, uid int64) (*domain.User, error)
        + CreateUser(ctx context.Context, user *domain.User) (int64, error)

    }
}
namespace auth {
    class "Auth" << (S,Aquamarine) >> {
        - repo Repository
        - jwt Jwt

        - getAuthResponse(userId int64) (*auth.AuthResponse, error)

        + Auth(ctx context.Context, request auth.AuthRequest, isNew bool) (*auth.AuthResponse, error)
        + Refresh(ctx context.Context, refreshToken string) (*auth.AuthResponse, error)

    }
    interface "Jwt"  {
        + NewToken(userId int64) (string, string, error)
        + ParseToken(tokenString string) (int64, error)

    }
    interface "Repository"  {
        + GetUserByLogin(ctx context.Context, login string) (*domain.User, error)
        + GetUserWithId(ctx context.Context, uid int64) (*domain.User, error)
        + CreateUser(ctx context.Context, user *domain.User) (int64, error)

    }
}
namespace logger {
}
"__builtin__.string" #.. "contextkeys.CtxKey"


"T" <-- "param" "ApiResponse_generic_T"

@enduml
